{
  "name": "PDFainatory ja->ru Translation Pipeline",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "pdfainatory/translate",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "Webhook_Trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        120,
        320
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const body = $json.body ?? $json;\nconst files = Array.isArray(body.files) ? body.files : (body.file ? [body.file] : []);\nif (!files.length) throw new Error('No input files provided.');\nconst sourceLang = body.langIn ?? 'ja';\nconst targetLang = body.langOut ?? 'ru';\nif (sourceLang !== 'ja' || targetLang !== 'ru') throw new Error('Pipeline currently supports only ja->ru.');\nconst allowedServices = ['openai', 'google', 'ollama'];\nconst requestedService = (body.service ?? 'openai').toLowerCase();\nif (!allowedServices.includes(requestedService)) throw new Error(`Unsupported service: ${requestedService}`);\nconst serviceChain = [requestedService, ...allowedServices.filter(s => s !== requestedService)];\nconst safePath = (p) => {\n  if (typeof p !== 'string' || !p.trim()) throw new Error('Invalid file path');\n  if (!/^[\\w@%+=:,./\\- ]+$/u.test(p)) throw new Error(`Unsafe path characters: ${p}`);\n  return p;\n};\nconst safeOptPath = (p) => p ? safePath(p) : '';\nreturn files.map((file, idx) => ({\n  json: {\n    runId: body.runId ?? `${Date.now()}-${idx}`,\n    inputFile: safePath(file),\n    outputDir: safePath(body.outputDir ?? '/data/output'),\n    langIn: sourceLang,\n    langOut: targetLang,\n    pages: body.pages ?? '',\n    poolMaxWorkers: Math.max(1, Math.min(8, Number(body.poolMaxWorkers ?? 2))),\n    customPromptPath: safeOptPath(body.customPromptPath ?? ''),\n    glossaryPath: safeOptPath(body.glossaryPath ?? ''),\n    primaryFontFamily: (body.primaryFontFamily ?? 'Noto Serif').replace(/[\"`]/g, ''),\n    serviceChain,\n    serviceIndex: 0,\n    currentService: serviceChain[0],\n    scannedHint: Boolean(body.scannedHint ?? false),\n    allowOcrWorkaround: Boolean(body.allowOcrWorkaround ?? false)\n  }\n}));"
      },
      "id": "Validate_Normalize",
      "name": "Validate & Normalize Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        360,
        320
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const f = $json.inputFile;\nif (!/\\.pdf$/i.test(f)) throw new Error(`Invalid file extension: ${f}`);\nreturn [{ json: { ...$json } }];"
      },
      "id": "Validate_PDF",
      "name": "Validate PDF Extension",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        320
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const scannedHint = Boolean($json.scannedHint ?? false);\nconst allowOcrWorkaround = Boolean($json.allowOcrWorkaround ?? false);\nif (scannedHint && !allowOcrWorkaround) {\n  return [{ json: { ...$json, scannedBlocked: true, code: 'SCANNED_REQUIRES_OCR', message: 'Scanned PDF detected. Pre-OCR is required before translation.' } }];\n}\nreturn [{ json: { ...$json, scannedBlocked: false } }];"
      },
      "id": "Evaluate_Scanned_Policy",
      "name": "Evaluate Scanned Policy",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        780,
        460
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.scannedBlocked}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "If_Scanned_Blocked",
      "name": "Scanned Blocked?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1020,
        460
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { runId: $json.runId ?? null, inputFile: $json.inputFile ?? null, status: 'warning', code: ($json.code || 'SCANNED_REQUIRES_OCR'), message: ($json.message || 'Scanned PDF requires OCR preprocessing'), action: 'run_ocr_then_retry' } }}",
        "options": {
          "responseCode": 409
        }
      },
      "id": "Respond_Scanned_Warning",
      "name": "Respond Scanned Warning",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1260,
        560
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const cmd = `qpdf --check \"${$json.inputFile}\"`;\nreturn [{ json: { ...$json, preflightCommand: cmd } }];"
      },
      "id": "Build_Preflight",
      "name": "Build Corrupt/Encrypted Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        860,
        320
      ]
    },
    {
      "parameters": {
        "command": "={{$json.preflightCommand}}"
      },
      "id": "Run_Preflight",
      "name": "Run PDF Preflight Check",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        1120,
        320
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{$json.exitCode || 0}}",
              "operation": "equal",
              "value2": 0
            }
          ]
        }
      },
      "id": "If_Preflight_OK",
      "name": "Preflight Passed?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1360,
        320
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const serviceFlagMap = { openai: '--openai', google: '--google', ollama: '--ollama' };\nconst pagesArg = $json.pages ? ` --pages \"${$json.pages}\"` : '';\nconst promptArg = $json.customPromptPath ? ` --custom-system-prompt \"${$json.customPromptPath}\"` : '';\nconst glossaryArg = $json.glossaryPath ? ` --glossaries \"${$json.glossaryPath}\"` : '';\nconst ocrArg = $json.allowOcrWorkaround ? ' --auto-enable-ocr-workaround' : '';\nconst serviceFlag = serviceFlagMap[$json.currentService] ?? '--openai';\nconst cmd = [\n  'pdf2zh-next',\n  `\"${$json.inputFile}\"`,\n  '--lang-in ja',\n  '--lang-out ru',\n  '--bilingual',\n  serviceFlag,\n  `--output \"${$json.outputDir}\"`,\n  `--pool-max-workers ${$json.poolMaxWorkers}`,\n  `--primary-font-family \"${$json.primaryFontFamily}\"`,\n  promptArg,\n  glossaryArg,\n  pagesArg,\n  ocrArg\n].filter(Boolean).join(' ');\nreturn [{ json: { ...$json, command: cmd } }];"
      },
      "id": "Build_Command",
      "name": "Build Translation Command",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        220
      ]
    },
    {
      "parameters": {
        "command": "={{$json.command}}"
      },
      "id": "Run_Primary",
      "name": "Run Translation",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        1840,
        220
      ],
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 3000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{$json.exitCode || 0}}",
              "operation": "equal",
              "value2": 0
            }
          ]
        }
      },
      "id": "If_Primary_OK",
      "name": "Primary Success?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2060,
        220
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const nextIndex = ($json.serviceIndex ?? 0) + 1;\nif (nextIndex >= $json.serviceChain.length) return [{ json: { ...$json, hasFallback: false } }];\nreturn [{ json: { ...$json, hasFallback: true, serviceIndex: nextIndex, currentService: $json.serviceChain[nextIndex] } }];"
      },
      "id": "Build_Fallback_Context",
      "name": "Build Fallback Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2280,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.hasFallback}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "If_Fallback_Available",
      "name": "Fallback Available?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2520,
        300
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const serviceFlagMap = { openai: '--openai', google: '--google', ollama: '--ollama' };\nconst pagesArg = $json.pages ? ` --pages \"${$json.pages}\"` : '';\nconst promptArg = $json.customPromptPath ? ` --custom-system-prompt \"${$json.customPromptPath}\"` : '';\nconst glossaryArg = $json.glossaryPath ? ` --glossaries \"${$json.glossaryPath}\"` : '';\nconst ocrArg = $json.allowOcrWorkaround ? ' --auto-enable-ocr-workaround' : '';\nconst serviceFlag = serviceFlagMap[$json.currentService] ?? '--ollama';\nconst cmd = [\n  'pdf2zh-next',\n  `\"${$json.inputFile}\"`,\n  '--lang-in ja',\n  '--lang-out ru',\n  '--bilingual',\n  serviceFlag,\n  '--ignore-cache',\n  `--output \"${$json.outputDir}\"`,\n  `--pool-max-workers ${$json.poolMaxWorkers}`,\n  `--primary-font-family \"${$json.primaryFontFamily}\"`,\n  promptArg,\n  glossaryArg,\n  pagesArg,\n  ocrArg\n].filter(Boolean).join(' ');\nreturn [{ json: { ...$json, fallbackCommand: cmd } }];"
      },
      "id": "Build_Fallback_Command",
      "name": "Build Fallback Command",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2760,
        220
      ]
    },
    {
      "parameters": {
        "command": "={{$json.fallbackCommand}}"
      },
      "id": "Run_Fallback",
      "name": "Run Fallback Translation",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        3000,
        220
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{$json.exitCode || 0}}",
              "operation": "equal",
              "value2": 0
            }
          ]
        }
      },
      "id": "If_Fallback_OK",
      "name": "Fallback Success?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        3220,
        220
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { runId: $json.runId, inputFile: $json.inputFile, outputDir: $json.outputDir, provider: $json.currentService, status: 'completed' } }}",
        "options": {}
      },
      "id": "Respond_Success",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        3460,
        200
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { runId: $json.runId ?? null, inputFile: $json.inputFile ?? null, status: 'error', code: 'PDF_PREFLIGHT_FAILED', message: ($json.stderr || $json.message || 'PDF is corrupted or password-protected') } }}",
        "options": {
          "responseCode": 422
        }
      },
      "id": "Respond_Preflight_Error",
      "name": "Respond Preflight Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1600,
        480
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { runId: $json.runId ?? null, inputFile: $json.inputFile ?? null, status: 'error', code: 'TRANSLATION_FAILED', providerTried: $json.serviceChain ?? [], message: ($json.stderr || $json.message || 'Translation failed across provider chain') } }}",
        "options": {
          "responseCode": 502
        }
      },
      "id": "Respond_Translation_Error",
      "name": "Respond Translation Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        3460,
        380
      ]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Validate & Normalize Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Normalize Input": {
      "main": [
        [
          {
            "node": "Validate PDF Extension",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate PDF Extension": {
      "main": [
        [
          {
            "node": "Evaluate Scanned Policy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Corrupt/Encrypted Check": {
      "main": [
        [
          {
            "node": "Run PDF Preflight Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run PDF Preflight Check": {
      "main": [
        [
          {
            "node": "Preflight Passed?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preflight Passed?": {
      "main": [
        [
          {
            "node": "Build Translation Command",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond Preflight Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Translation Command": {
      "main": [
        [
          {
            "node": "Run Translation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Translation": {
      "main": [
        [
          {
            "node": "Primary Success?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Primary Success?": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Fallback Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Fallback Context": {
      "main": [
        [
          {
            "node": "Fallback Available?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fallback Available?": {
      "main": [
        [
          {
            "node": "Build Fallback Command",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond Translation Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Fallback Command": {
      "main": [
        [
          {
            "node": "Run Fallback Translation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Fallback Translation": {
      "main": [
        [
          {
            "node": "Fallback Success?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fallback Success?": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond Translation Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Evaluate Scanned Policy": {
      "main": [
        [
          {
            "node": "Scanned Blocked?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scanned Blocked?": {
      "main": [
        [
          {
            "node": "Respond Scanned Warning",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Corrupt/Encrypted Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
